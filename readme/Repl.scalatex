@import Main._
@import readme.Sample._
@import ammonite.ops._
@val ammoniteTests = 'amm/'src/'test/'scala/'ammonite/'session
@val advancedTests = ammoniteTests/"AdvancedTests.scala"
@sect("Ammonite-REPL", "A Modernized Scala REPL")

  @p
    The @b{Ammonite-REPL} is an improved Scala REPL, re-implemented from first
    principles. It is much more featureful than the default REPL and comes
    with a lot of @sect.ref("Features", "ergonomic improvements") and
    @sect.ref("Configuration", "configurability") that may be familiar to
    people coming from IDEs or other REPLs such as @lnk("IPython",
    "https://ipython.org/") or @lnk("Zsh", "http://www.zsh.org/").

  @p
    It can be combined with @sect.ref{Ammonite-Ops} to replace Bash as your
    systems shell, but also can be used alone as a @sect.ref("Features",
    "superior") version of the default Scala REPL, or as a
    @sect.ref("Debugging", "debugging tool"), or for many other
    @sect.ref("Ammonite Cookbook", "fun and interesting things")!


  @p
    If you want to use Ammonite as a plain Scala shell, download the
    standalone executable for Scala 2.12 (also available for
    @sect.ref{Older Scala Versions}):

  @hl.sh
    @replCurl

  @p
    This will give you access to the Ammonite-REPL:

  @img(src:="GettingStarted.png", width:="100%")

  @p
    With @sect.ref("Pretty-printed output", "Pretty Printing"),
    @sect.ref{Syntax Highlighting} for input and output,
    @sect.ref("import $ivy", "Artifact Loading") in-REPL, and all the other nice
    @sect.ref{Features}!

  @p
    If you want to use Ammonite as a filesystem shell, take a look at
    @sect.ref{Ammonite-Shell}. If you're not sure what to do with Ammonite,
    check out the @sect.ref{Ammonite Cookbook} for some fun ideas!

  @p
    If you want some initialization code available to the REPL, you can add
    it to your @code{~/.ammonite/predef.sc}.
  @p
    If you have any questions, come hang out on the @sect.ref("Community",
     "mailing list or gitter channel") and get help!


  @p
    You can also try out Ammonite in an existing SBT project, add the
    following to your @code{build.sbt}

  @hl.scala
    libraryDependencies += "com.lihaoyi" % "ammonite" % "@ammonite.Constants.version" % "test" cross CrossVersion.full

    sourceGenerators in Test += Def.task {
      val file = (sourceManaged in Test).value / "amm.scala"
      IO.write(file, """object amm extends App { ammonite.Main().run() }""")
      Seq(file)
    }.taskValue

  @p
    After that, simply hit

  @code
    sbt projectName/test:run

  @p
    or if there are other main methods in the @code{Test} scope

  @code
    sbt projectName/test:run-main amm

  @p
    To activate the Ammonite REPL

  @p
    You can also pass a string to the @code{Main} call containing any
    commands or imports you want executed at the start of every run, along
    with @lnk("other configuration",
    "http://www.lihaoyi.com/Ammonite/api/repl/index.html#ammonite.Main").
    If you want Ammonite to be available in all projects, simply add the
    above snippet to a new file @code{~/.sbt/0.13/global.sbt}.

  @p
    Note: Ammonite-REPL does @i{not} support Windows, even though
    @sect.ref{Ammonite-Ops} does. See @lnk("#119",
    "https://github.com/lihaoyi/Ammonite/issues/119") if you are interested
    in details or want to try your hand at making it work.

  @sect{Features}
    @p
      Ammonite-REPL supports many more features than the default REPL, including:

    @sect{Pretty-printed output}

      @hl.ref(advancedTests, Seq("'pprint", "@"), "\"\"\"")

      @p
        Ammonite-REPL uses @lnk("PPrint", "https://lihaoyi.github.io/upickle-pprint/pprint/") to display its output by default. That means that everything is nicely formatted to fit within the width of the terminal, and is copy-paste-able!

      @p
        By default, Ammonite @sect.ref("Configurable Truncation", "truncates")
        the pretty-printed output to avoid flooding your terminal. If you want
        to disable truncation, call @hl.scala{show(...)} on your expression to
        pretty-print it's full output. You can also pass in an optional
        @hl.scala{height = ...} parameter to control how much you want to show
        before truncation.

      @sect{Configurable Truncation}
        @hl.ref(advancedTests, Seq("'truncation", "@"), "\"\"\"")

        @p
          Ammonite-REPL intelligently truncates your output when it's beyond a
          certain size. You can request for the full output to be printed
          on-demand, print a certain number of lines, or even change the implicit
          @code{pprintConfig} so subsequent lines all use your new configuration.

    @sect{Editing}
      @p
        Ammonite by default ships with a custom implementation of readline, which
        provides...

      @sect{Syntax Highlighting}
        @img(src:="Highlighting.png", width:="100%")
        @p
          Ammonite syntax highlights both the code you're entering as well as any
          output being echoed in response. This should make it much easier to
          work with larger snippets of input.
        @p
          All colors are configurable, and you can easily turn off colors entirely
          via the @sect.ref{Configuration}.
        @p
          Stack traces are similarly highlighted, for easier reading:

        @img(src:="ColoredTraces.png", width:="100%")
      @sect{Multi-line editing}

        @p
          You can use the @b{Up} and @b{Down} arrows to navigate between lines
          within your snippet. @code{Enter} only executes the code when you're
          on the last line of a multi-line snippet, meaning you can take your
          time, space out your code nicely, and fix any mistakes anywhere in your
          snippet. History is multi-line too, meaning re-running a multi-line
          snippet is trivial, even with tweaks.

        @p
          Long gone are the days where you're desperately trying to cram
          everything in a single line, or curse quietly when you notice a mistake
          in an earlier line you are no longer able to fix. No more painstakingly
          crafting a multi-line snippet, and then having to painstakingly fish it
          line by individual line out of the history so you can run it again!

      @sect{Desktop key-bindings}
        @img(src:="Editing.gif", display.block, marginLeft.auto, marginRight.auto, height := 172)
        @p
          You can use @b{Alt-Left}/@b{Right} to move forward/backwards by one
          word at a time or hold down @b{Shift} to select text to delete. These
          compose as you'd be used to: e.g. @b{Shift-Up} selects all the text
          between your current cursor and the same column one row up.

        @p
          @code{Tab} and @code{Shift-Tab} now work to block-indent and -dedent
          sections of code, as you'd expect in any desktop editor like Sublime
          Text or IntelliJ. This further enhances the multi-line editing
          experience, letting your nicely lay-out your more-complex REPL commands
          the same way you'd format code in any other editor.

      @sect{Console key-bindings}
        @p
          All the readline-style navigation hotkeys like @b{Ctrl-W} to delete a
          word or @b{Esc-Left}/@b{Right} to navigate one word left/right still
          work. If you're comfortable with consoles like Bash, Python, IPython or
          even the default Scala console, you should have no trouble as all the
          exact same hotkeys work in Ammonite

      @sect{History Search}

        @img(src:="HistorySearch.gif", width:="445px", marginRight.auto, marginLeft.auto, display.block)

        @p
          Apart from browsing your command-line history with @code{UP}, you can
          also perform a history search by entering some search term and @i{then}
          pressing @code{UP}. That will pull up the most recent history line with
          that term in it, underlined. You can continue to press @code{UP} or
          @code{DOWN} to cycle through the matches, or @code{Backspace} or
          continue typing characters to refine your search to what you want.
        @p
          You can press @code{TAB}, or any other command character (@code{LEFT},
          @code{RIGHT}, ...) to end the search and let you continue working with
          the currently-displayed command. Pressing @code{ENTER} will end the
          search and immediately submit the command to be run.
        @p
          You can also kick off a history search using @code{Ctrl-R}, and use
          @code{Ctrl-R} to cycle through the matches.

      @sect{Block Input}
        @p
          To enter block input (many independent lines all at once) into the
          Ammonite-REPL, simply wrap the multiple lines in curly braces
          @hl.scala("{ ... }"), and Ammonite will wait until you close it before
          evaluating the contents:

        @hl.ref(advancedTests, Seq("'unwrapping", "@"))

        @p
          As you can see, the contents of the @hl.scala("{ ... }") block are
          unwrapped and evaluated as top-level statements. You can use this to
          e.g. declare mutually recursive functions or classes &
          companion-objects without being forced to squeeze everything onto a
          single line.

        @p
          If you don't want this un-wrapping behavior, simply add another set of
          curlies and the block will be evaluated as a normal block, to a single
          expression:

        @hl.ref(advancedTests, Seq("'forceWrapping", "@"))

      @sect{Undo & Redo}
        @img(src:="UndoRedo.gif", display.block, marginLeft.auto, marginRight.auto, height := 154)
        @p
          The Ammonite command-line editor allows you to undo and re-do portions
          of your edits:
        @ul
          @li
            @code{Ctrl -}: Undo last change
          @li
            @code{Alt/Esc -}: Redo last change

        @p
          Each block of typing, deletes, or navigation counts as one undo. This
          should make it much more convenient to recover from botched copy-pastes
          or bulk-deletions.


    @sect{Magic Imports}
      @p
        Ammonite provides a set of magic imports that let you load additional
        code into a REPL session: these are imports which start with a @code{$},
        and are *top-level* inside the REPL command or your
        @sect.ref{Scala Scripts}.

      @sect{import $file}
        @p
          This lets you load @sect.ref{Scala Scripts} into the REPL. For
          example given a small script defining one value we want
        @hl.scala
          // MyScript.sc
          val elite = 31337

        @p
          We can load it into our REPL session using:

        @hl.scala
          @@ import $file.MyScript

          @@ MyScript.elite
          res1: Int = 31337

        @p
          If the script is in a sub-folder, simply use:

        @hl.scala
          @@ import $file.myfolder.MyScript

        @p
          Or if the script is in an @i{outer} folder,

        @hl.scala
          @@ import $file.`..`.MyScript

        @p
          Or if we want to import the contents of the script in one go:

        @hl.scala
          @@ import $file.MyScript, MyScript._
          import $file.$

          @@ elite
          res1: Int = 31337

        @p
          While this is a trivial example, your @code{MyScript.sc} file can
          contain anything you want, not just @hl.scala{val}s: function
          @hl.scala{def}s, @hl.scala{class}es @hl.scala{object}s or
          @hl.scala{trait}s, or imports from @i{other} scripts. For more
          documentation on how these scripts work, check out the
          @sect.ref{Scala Scripts} section.

        @p
          There are some subtleties when dealing with @hl.scala{$file} imports
          that are worth remembering
        @ul
          @li
            @sect.ref{Imported Scripts are Re-used}
          @li
            @sect.ref{Cannot directly import from inside a Script}
          @li
            @sect.ref{Renamed-scripts and multiple-scripts}

        @p
          Note you can also perform file imports from your
          @sect.ref("Configuration", "predef file"), which are resolved relative to
          that file's path. This is useful if your predef is large and you want to
          break it up into multiple files.

        @sect{Imported Scripts are Re-used}
          @p
            Note that script files imported multiple times are re-used; even if
            the same script is imported multiple times, it will only be compiled
            once, and its top-level definitions or statements will only be
            evaluated once. If you want to run code over and over, @hl.scala{def}
            a function in the script you are importing and you can call it
            repeatedly.
          @p
            If you want to re-load a script, you should use Ammonite's
            @sect.ref{Save/Load Session} functionality to @hl.scala{sess.save()}
            the session before importing the script, and @hl.scala{sess.load()}ing
            to reset the script before re-@hl.scala{import}ing it.

        @sect{Cannot directly import from inside a Script}
          @p
             You cannot import things from "inside" that script in
            one chain:

          @hl.scala
            @@ import $file.MyScript._

          @p
            Rather, you must always import the script-object first, and then import
            things from the script object after:

          @hl.scala
            @@ import $file.MyScript, MyScript._

        @sect{Renamed-scripts and multiple-scripts}

          @p
            You can re-name scripts on-import if you find their names are
            colliding:

          @hl.scala
            @@ import $file.{MyScript => FooBarScript}, FooBarScript._

          @p
            Or import multiple scripts at once

          @hl.scala
            @@ import $file.{MyScript, MyOtherScript}

          @p
            These behave as you would expect imports to work. Note that when
            importing multiple scripts, you have to name them explicitly and
            cannot use wildcard `._` imports:

          @hl.scala
            @@ import $file._ // doesn't work

      @sect{import $exec}
        @p
          This is similar to @hl.scala{import $file}, except that it dumps the
          definitions and imports from the script into your REPL session. This is
          useful if you are using a script to hold a set of common imports, the
          docs for @sect.ref{Scala Scripts} has more on this.

      @sect{import $ivy}
        @p
          Lets you import Ivy dependencies from Maven Central, or anywhere else.
          For example, here is loading @lnk("Scalaz",
          "https://github.com/scalaz/scalaz") and using it in the Ammonite-REPL:

        @hl.ref(ammoniteTests/"ProjectTests.scala", Seq("'scalaz", "@"))

        @p
          Note that the different portions of the @hl.scala{$ivy} import are
          in a @code{org::library:version} format; the @code{::} is used to represent
          Scala dependencies, similar to @hl.scala{%%} in SBT's dependency syntax.
          If you want Java dependencies, you can load them using the
          @code{org:library:version} format, e.g. here we load the
          @lnk("Google Guava", "https://github.com/google/guava") Java library

        @hl.ref(ammoniteTests/"ProjectTests.scala", Seq("'guava", "@"))

        @p
          If you want to load a compiler plugin, you can do so using
          @hl.scala{import $ivy.$plugin}:

        @hl.ref(ammoniteTests/"AdvancedTests.scala", Seq("'compilerPlugin", "@"))

        @p
          This makes Ammonite ideal for trying out new libraries or tools. You
          can pull down projects like @lnk("Scalaz",
          "https://github.com/scalaz/scalaz") or @lnk("Shapeless",
          "https://github.com/milessabin/shapeless") and immediately start
          working with them in the REPL:

        @hl.ref(ammoniteTests/"ProjectTests.scala", Seq("shapeless", "@"), "\"\"\"")

        @p
          Even non-trivial web frameworks like Finagle or Akka-HTTP can be
          simply pulled down and run in the REPL!

        @hl.ref(ammoniteTests/"ProjectTests.scala", Seq("finagle", "@"), "\"\"\"")

        @p
          Ammonite-REPL is configured with a set of default resolvers but you
          can add your own using
          @lnk("Coursier's Repository APIs", "https://github.com/coursier/coursier#api-1")

        @hl.ref(ammoniteTests/"ProjectTests.scala", Seq("resolvers", "@"), "\"\"\"")

        @p
          Including repositories which need authentication:

        @hl.scala
          import coursier.core.Authentication, coursier.MavenRepository

          interp.repositories() ++= Seq(MavenRepository(
            "https://nexus.corp.com/content/repositories/releases",
            authentication = Some(Authentication("user", "pass"))
          ))

        @p
          If you need more detailed control over what you are importing, e.g.
          with attributes, classifiers or exclusions, you can fall back to
          using the @hl.scala{interp.load.ivy(deps: coursier.Dependency*)}
          function and configure each @code{Dependency} to your heart's content:

        @hl.ref(ammoniteTests/up/"ScriptTests.scala", Seq("loadIvyAdvanced", "@"), "\"\"\"")

    @sect{Builtins}
      @p
        The Ammonite REPL contains a bunch of built-in imports and definitions by
        default. This includes:

      @ul
        @li
          @hl.scala{repl}: the object representing the Repl API, aliased as
          @hl.scala{repl}. This allows you (e.g. @hl.scala{repl.history})
          and you can use autocomplete or @hl.scala{typeOf} on the
          @hl.scala{repl} object to see what is available.
        @li
          @sect.ref{Utilities}: tools such as @sect.ref{time}, @sect.ref{grep}
          or @sect.ref{browse} that are independent from the REPL, but are
          extremely useful to have in it.

      @p
        All of these are imported by default into any Ammonite REPL, in order to
        provide a rich and consistent REPL experience. If you want to disable
        these imports and run the REPL with a clean namespace (with only the core
        implicits needed for result pretty-printing/type-printing to work) pass
        in @hl.scala{defaultPredef = false} to the REPL's @hl.scala{Main} API or
        @hl.scala{--no-default-predef} to the REPL from the command-line.

      @sect{Repl API}
        @p
          Ammonite contains a range of useful built-ins implemented as normal
          functions on the @code{repl} and @code{interp} objects, e.g.
          @code{repl.history}, @code{repl.width}, @code{repl.frontEnd()} to
          change the front-end terminal implementation, etc.:

        @hl.ref('amm/'repl/'src/'main/'scala/'ammonite/'repl/"ReplAPI.scala", "trait ReplAPI", "// End of ReplAPI")

        @p
          All of these are available as part of the @hl.scala{repl} object
          which is imported in scope by default. Additional
          functionality available under the @code{interp} object, which is also
          available in scripts:

        @hl.ref('amm/'interp/'src/'main/'scala/'ammonite/'interp/"InterpAPI.scala", "trait InterpAPI")

      @sect{Utilities}
        @p
          Apart from the core @sect.ref{Builtins} of the REPL, the Ammonite REPL
          also includes many helpers that are not strictly necessarily but are
          very useful in almost all REPL sessions. Here are a few of them

        @ul
          @li
            @sect.ref{time}
          @li
            @sect.ref{grep}
          @li
            @sect.ref{browse}
          @li
            @sect.ref{desugar}

        @p
          The REPL also imports the @sect.ref("Extensions", "pipe-operators")
          from Ammonite-Ops by default to make it easy for you to use tools like
          @sect.ref{grep} interactively, and imports all the @sect.ref{Builtins}
          from the @hl.scala{repl}.

        @p
          These tools are useful but not strictly necessary;

        @sect{time}
          @compare("time ls -a", "time{ls!}")

          @p
            Just as bash provides a @code{time} command that you can use to see
            how long a command took to run, Ammonite-Shell provides a
            @hl.scala{time} function which serves the same purpose.
          @p
            While the bash version spits out the time in an ad-hoc table format,
            stuck together with the output of the command, Ammonite-Shell's
            @hl.scala{time} instead returns a tuple containing the expression
            that was evaluated, and the time taken to evaluate it.

        @sect{grep}
          @compare("ls -a . | grep re", """ls! wd || grep! "re" """)
          @compare("ls -a . | grep re", """ls! wd |? grep! "re" """)

          @p
            Ammonite provides its own @hl.scala{grep} command, which lets you
            easily perform ad-hoc searches within a list.
          @p
            As shown above, Ammonite's @hl.scala{grep} can be used via
            @hl.scala{||} (@hl.scala{flatMap}) or @hl.scala{|?}
            (@hl.scala{filter}). In the case of @hl.scala{||}, it displays the
            matches found, highlighted, with some additional context before and
            after the match. When used with @hl.scala{|?}, it simply returns the
            relevant items. In general, @hl.scala{||} is useful for manual
            exploration, while @hl.scala{|?} is useful in scripts where you want
            to deal with the list of matched results later.
          @p
            By default, Ammonite's @hl.scala{grep} matches a string as a literal.
            If you want to match via a regex, append a @hl.scala{.r} to the
            string literal to turn it into a regex:

          @compare("""ls -a . | grep -G "re[a-z]\+" """, """ls! wd || grep! "re[a-z]+".r """)

          @p
            Ammonite's @hl.scala{grep} isn't limited to "filesystem"-y things;
            @i{any} collection of objects can be piped through @hl.scala{grep}!
            For example, here's @hl.scala{grep} being used to quickly search
            through the JVM system properties:

          @pre(ammSample(
            """// I'm only interested in OS-related properties, show them to me!
              |sys.props || grep! "os|OS".r""".stripMargin
          ))

          @p
            You can even use Ammonite's @hl.scala{grep} to dig through the
            methods of an object, even large messy objects with far-too-many
            methods to go over by hand hunting for what you want:

          @pre(ammSample(
            """typeOf(repl.compiler).members.size // Too many methods to dig through!
              |// I forgot what I want but I think it has Raw in the name
              |typeOf(repl.compiler).members || grep! "Raw" """.stripMargin
          ))
          @p
            In general, Ammonite's @hl.scala{grep} serves the same purpose of
            @code{grep} in the Bash shell: a quick and dirty way to explore large
            amounts of semi-structured data. You probably don't want to build
            your enterprise business logic on top of @hl.scala{grep}'s string
            matching. While you're working, though, @hl.scala{grep} can be a
            quick way to find items of interest in collections of things
            (anything!) too large to sift through by hand, when you're not yet
            sure exactly what you want.

        @sect{browse}

          @img(src:="Browse.gif", display.block, marginLeft.auto, marginRight.auto, height := 278)

          @p
            @hl.scala{browse} is a utility that lets you open up far-too-large
            data structures in the @code{less} pager, letting you page through
            large quantities of text, navigating around it and searching through
            it, without needing to spam your terminal output with its contents
            and losing your earlier work to the output-spam. Simple call
            @hl.scala{browse} on whatever value you want, e.g. this 50 thousand
            line @hl.scala{ls.rec} result show above.

          @p
            If you're dealing with large blobs of data that you want to dig
            through manually, you might normally format it nicely, write it to
            a file, and open it in @code{vim} or @code{less} or an editor such
            as Sublime Text. @hl.scala{browse} makes that process quick and
            convenient.

          @p
            You can customize the @hl.scala{browse} call like you would a
            @hl.scala{show} call or @hl.scala{pprint.pprintln} call, e.g. setting
            an optional @hl.scala{width}, @hl.scala{colors} or @hl.scala{indent}.
            You can also choose a @hl.scala{viewer} program in case you don't
            want to use @code{less}: e.g. here's a command that would open it up
            in @code{vim}:

          @hl.scala
            haoyi-Ammonite@@ browse(res0, viewer="vim", colors = pprint.Colors.BlackWhite)

          @p
            Apart from using @hl.scala{viewer="vim"}, we also set the
            @hl.scala{colors} to black and white because Vim by default doesn't
            display ANSI colors nicely. You can also pass in a @hl.scala{Seq} of
            strings to @hl.scala{viewer} if you want to pass additional flags to
            your editor, and of course use any other editor you would like such
            as @hl.scala{"emacs"} or @hl.scala{"nano"} or @hl.scala{"subl"}

        @sect{desugar}
          @img(src:="Desugar.png", display.block, marginLeft.auto, marginRight.auto, height := 495)

          @p
            @hl.scala{desugar} allows you to easily see what the compiler is
            doing with your code before it gets run. For example, in the above
            calls to @hl.scala{desugar}, you can see:

          @ul
            @li
              @hl.scala{List(...)} being converted to @hl.scala{List.apply(...)}
            @li
              @hl.scala{true -> false} being converted to
              @hl.scala{Predef.ArrayAssoc(true).$minus$greater(false)}
            @li
              @hl.scala{default.write$default}, @hl.scala{default.SeqishW}, etc.
              being injected as implicits
            @li
              @hl.scala{for} comprehensions with @hl.scala{if} filters being
              converted into the relevant @hl.scala{withFilter} and @hl.scala{map}
              calls

          @p
            In general, if you are having trouble understanding the combination
            of implicit parameters, implicit conversions, macros, and other odd
            Scala features, @hl.scala{desugar} could you see what is left after
            all the magic happens.
          @p
            @hl.scala{desugar} only works in Scala 2.11.x and above, not in 2.10.x

    @sect{Save/Load Session}
      @p
        Ammonite allows you to save your work half way through, letting you
        discard and future changes and returning to the state of the world you
        saved.

      @p
        Defined some memory-hogging variable you didn't need? Loaded the wrong
        version of some third-party library? Reluctant to reload the REPL
        because reloading is slow? Fear not! With Ammonite, you can save your
        important work, do whatever you want later, and simply discard all the
        jars you loaded, variables you defined

      @hl.ref(ammoniteTests/"BuiltinTests.scala", Seq("'saveLoad", "@"))
      @p
        Apart from plain @hl.scala{save}s and @hl.scala{load}s, which simply
        discard everything after the most recent save, you can also provide a
        name to these functions. That lets you stop working on a branch, go do
        something else for a while, and be able to come back later to continue
        where you left off:

      @hl.ref(ammoniteTests/"BuiltinTests.scala", Seq("'saveLoad2", "@"))


      @p
        Lastly, you have the @hl.scala{repl.sess.pop()} function. Without any
        arguments, it behaves the same as @hl.scala{repl.sess.load()}, reseting you
        to your last savepoint. However, you can pass in a number of session
        frames which you'd like to pop, allow you to reset your session to even
        earlier save points. @hl.scala{repl.sess.pop(2)} would put you two
        save-points ago, @hl.scala{repl.sess.pop(3)} would put you three save-points
        ago, letting you reach earlier save-points even if you did not give
        them names. Passing in a large number like @hl.scala{repl.sess.pop(999)}
        would reset your session all the way until the start.

      @p
        Ammonite's @hl.scala{save} and @hl.scala{load} functionality is
        implemented via Java class-loaders.

    @sect{Superior Autocomplete}
      @p
        The original Scala REPL provides no autocomplete except for the most
        basic scenarios of @hl.scala{value.<complete>}. In the Ammonite-REPL,
        you get the same autocomplete-anywhere support that you get in a modern
        IDE.

      @hl.scala("""
        @ Seq(1, 2, 3).map(x => x.)
        getClass            ##                  asInstanceOf        isInstanceOf
        toString            hashCode            equals              !=
        ==                  %                   /                   *
        -                   +                   ^                   &
        |                   >=                  >                   <=
        <                   >>                  >>>                 <<
        unary_-             unary_+             unary_~             toDouble
        toFloat             toLong              toInt               toChar
        toShort             toByte              compareTo           doubleValue
        ...

        @ Futu
        scala.collection.parallel.FutureThreadPoolTasks
        scala.collection.parallel.FutureTasks
        scala.concurrent.impl.Future$PromiseCompletingRunnable
        scala.concurrent.impl.Future
        scala.concurrent.Future
        scala.concurrent.FutureTaskRunner
        scala.concurrent.Future$InternalCallbackExecutor
        scala.concurrent.Future$class
        java.util.concurrent.Future
        java.util.concurrent.FutureTask$WaitNode
        java.util.concurrent.FutureTask
        com.sun.corba.se.impl.orbutil.closure.Future
      """)

      @p
        Neither of these examples work in the standard Scala REPL.

    @sect{Interrupting run-away execution with Ctrl-C}
      @hl.scala("""
        @ while(true) ()
        ... hangs ...
        ^Ctrl-C
        Interrupted!

        @
      """)
      @p
        The traditional Scala REPL doesn't handle runaway code, and gives you
        no option but to kill the process, losing all your work. Ammonite-REPL
        lets you interrupt the thread, stop the runaway-command and keep going.

    @sect{Compiler-crash Robustness}
      @hl.ref(ammoniteTests/"FailureTests.scala", Seq("compilerCrash", "@"), "\"\"\"")

      @p
        The default Scala REPL throws away all your work if the compiler
        crashes. This doesn't make any sense, because all the compiler is is
        a dumb @hl.scala{String => Array[Byte]} pipe. In the Ammonite, we
        simply swap out the broken compiler for a new one and let you continue
        your work.

    @sect{Other Fixes}
      @p
        Apart from the above features, the Ammonite REPL fixes a large number
        of bugs in the default Scala REPL, including but not limited to:
      @ul
        @val bugs = Seq("6302", "8971", "9249", "4438", "8603", "6660", "7953", "6659", "8456", "1067", "8307", "9335")
        @for(bug <- bugs){
          @li(a("SI-"+bug, href:="https://issues.scala-lang.org/browse/SI-"+bug))
        }


  @sect{Configuration}
    @p
      Ammonite is configured via Scala code, that can live in the
      @code{~/.ammonite/predef.sc} file, passed in through SBT's
      @hl.scala{initialCommands}, or passed to the command-line executable as
      @code{--predef='...'}.

    @p
      Anything that you put in @code{predef.sc} will be executed when you
      load the Ammonite REPL. This is a handy place to put common imports,
      setup code, or even call @hl.scala{import $ivy} to
      @sect.ref("import $ivy", "load third-party jars"). The compilation
      of the predef is cached, so after the first run it should not noticeably
      slow down the initialization of your REPL.

    @p
      Some examples of things you can configure:

    @hl.ref(ammoniteTests/"BuiltinTests.scala", Seq("basicConfig", "@"))

    @sect{Refs}
      @p
        By default, all the values you're seeing here with the @code{()} after
        them are @hl.scala{Ref}s, defined as

      @hl.ref('amm/'util/'src/'main/'scala/'ammonite/'util/"Model.scala", "trait StableRef", "object Ref")

      @p
        As you can see from the signature, you can basically interact with the
        @hl.scala{Ref}s in two ways: either getting or setting their values as
        values, or binding their values to expressions that will be evaluated
        every time the @hl.scala{Ref}'s value is needed.

      @p
        As an example of the latter, you can use @hl.scala{bind} to set your
        @hl.scala{prompt} to always include your current working directory

      @hl.scala
        repl.prompt.bind(wd.toString + "@@ ")

      @p
        As is common practice in other shells. Further modifications to make it
        include e.g. your current branch in Git (which you can call through
        Ammonite's @sect.ref("Spawning Subprocesses", "subprocess API") or the
        current timestamp/user are similarly possible.

    @sect{Compiler Flags}
      @p
        Apart from configuration of the rest of the shell through
        @sect.ref{Refs}, configuration of the Scala compiler takes place
        separately through the compiler's own configuration mechanism. You have
        access to the compiler as @code{compiler}, and can modify its settings
        as you see fit. Here's an example of this in action:

      @hl.ref(ammoniteTests/"BuiltinTests.scala", Seq("settings", "@"))

      @p
        If you want these changes to always be present, place them in your
        @code{~/.ammonite/predef.sc}.

    @sect{JVM Flags}
      @p
        Ammonite also supports the @code{JAVA_OPTS} environment variable for
        passing arguments to the JVM that it runs inside, e.g. you can pass in
        a custom memory limit via

      @hl.scala
        bash$ JAVA_OPTS="-Xmx1024m" amm

      @p
        To start the REPL while letting it use only up to 1024 megabytes of memory

  @sect{Embedding}
    @p
      The Ammonite REPL is just a plain-old-Scala-object, just like any other
      Scala object, and can be easily used within an existing Scala program.
      This is useful for things like interactive @sect.ref{Debugging} or
      hosting a @sect.ref{Remote REPL} to interact with a long-lived Scala
      process, or @sect.ref{Instantiating Ammonite} inside an existing program
      to serve as a powerful interactive console.

    @sect{Instantiating Ammonite}
      @p
        To use Ammonite inside an existing Scala program, you need to first add
        it to your dependencies:

      @hl.scala
        libraryDependencies += "com.lihaoyi" % "ammonite" % "@ammonite.Constants.version" cross CrossVersion.full

      @p
        Then instantate it with this code anywhere within your program:

      @hl.ref('integration/'src/'test/'scala/'ammonite/'integration/"TestMain.scala")

      @p
        You can configure the instantiated REPL by passing in arguments to the
        @hl.scala{Main()} call, e.g. to redirect the input/output streams or to
        run a @hl.scala{predef} to configure it further.

    @sect{Debugging}
      @p
        Ammonite can be used as a tool to debug any other Scala program, by
        conveniently opening a REPL at any point within your program with which
        you can interact with live program data, similar to pdb/ipdb in Python.
        To do so, first add Ammonite to your classpath, e.g. through this SBT
        snippet:

      @hl.scala
        libraryDependencies += "com.lihaoyi" % "ammonite" % "@ammonite.Constants.version" cross CrossVersion.full

      @p
        Note that unlike the snippet given @sect.ref("Ammonite-REPL", "above"), we
        leave out the @hl.scala{% "test"} because we may want ammonite to be
        available within the "main" project, and not just in the unit tests.
        Then, anywhere within your program, you can place a breakpoint via:

      @hl.ref(wd/'integration/'src/'test/'scala/'ammonite/'integration/"TestMain.scala")

      @p
        And when your program reaches that point, it will pause and open up an
        Ammonite REPL with the values you provided it bound to the names you
        gave it. From there, you can interact with those values as normal Scala
        values within the REPL. Use @code{Ctrl-D} or @hl.scala{exit} to exit the
        REPL and continue normal program execution. Note that the names given
        must be plain Scala identifiers.

      @p
        Here's an example of it being used to debug changes to the
        @lnk("WootJS webserver", "https://github.com/d6y/wootjs"):

      @img(src:="Debugging.png", width:="100%")
      @p
      In this case, we added the @hl.scala{debug} statement within the
      websocket frame handler, so we can inspect the values that are taking
      part in the client-server data exchange. You can also put the
      @hl.scala{run} statement inside a conditional, to make it break only
      when certain interesting situations (e.g. bugs) occur.

      @p
        As you can see, you can bind the values you're interested in to names
        inside the debug REPL, and once in the REPL are free to explore them
        interactively.
      @p
        The @hl.scala{debug()} call returns @hl.scala{: Any}; by default, this
        is @hl.scala{(): Unit}, but you can also return custom values by
        passing in an argument to @hl.scala{exit(...)} when you exit the REPL.
        This value will then be returned from @hl.scala{debug()}, and can be
        used in the rest of your Scala application.

    @sect{Remote REPL}

      @p
        Ammonite can also be used to remotely connect to your running
        application and interact with it in real-time, similar to Erlang's
        @code{erl -remsh} command.

      @p
        This is useful if e.g. you have multiple Scala/Java processes running
        but aren't sure when/if you'd want to inspect them for debugging, and
        if so which ones. With Ammonite, you can leave a ssh server running in
        each process. You can then and connect-to/disconnect-from each one at
        your leisure, working with the in-process Scala/Java objects and
        methods and classes interactively, without having to change code and
        restart the process to add breakpoints or instrumentation.

      @p
        To do this, add ammonite-sshd to your classpath, for example with SBT:

      @hl.scala
        libraryDependencies += "com.lihaoyi" % "ammonite-sshd" % "@ammonite.Constants.version" cross CrossVersion.full

      @p
        Now add repl server to your application:

      @hl.scala
        import ammonite.sshd._
        val replServer = new SshdRepl(
          SshServerConfig(
            address = "localhost", // or "0.0.0.0" for public-facing shells
            port = 22222, // Any available port
            passwordAuthenticator = Some(pwdAuth) // or publicKeyAuthenticator
          )
        )
        replServer.start()

      @p
        And start your application. You will be able to connect to it using ssh
        like this: @hl.sh("ssh repl@localhost -p22222") and interact with your
        running app. Invoke @hl.scala{stop()} method whenever you want to
        shutdown ammonite sshd server. Here for example sshd repl server is
        embedded in the @lnk("Akka HTTP microservice example",
        "https://github.com/theiterators/akka-http-microservice"):

      @img(src:="DebuggingViaSshd.png", width:="100%")

      @p
        Here we can interact with code live, inspecting values or calling
        methods on the running system. We can try different things, see which
        works and which not, and then put our final bits in application code.
        In this example app is located on local machine, but you are free to
        connect to any remote node running your code.

      @p
        @b{Security notes:} It is probably unsafe to run this server publicly
        (on host @hl.scala{"0.0.0.0"}) in a production, public-facing
        application.  If you insist on doing so, you probably want key-based
        authentication, available by supplying @hl.scala{publicKeyAuthenticator}
        in the @hl.scala{SshServerConfig}.

      @p
        Despite this, it is perfectly possible to run these on production
        infrastructure: simply leave the @hl.scala{host} set to
        @hl.scala{"localhost"}, and rely on the machine's own SSH access to
        keep out unwanted users: you would first @code{ssh} onto the machine
        itself, and then @code{ssh} into the Ammonite REPL running on
        @code{localhost}.

      @p
        Typically most organizations already have bastions, firewalls, and
        other necessary infrastructure to allow trusted parties SSH access to
        the relevant machines. Running on @code{localhost} lets you leverage
        that and gain all the same security properties without having to
        re-implement them in Scala.
