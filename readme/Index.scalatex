@import Main._
@import ammonite.ops._
@val ammoniteTests = 'repl/'src/'test/'scala/'ammonite/'repl/'session
@val replSource = 'repl/'src/'main/'scala/'ammonite/'repl
@val advancedTests = ammoniteTests/"AdvancedTests.scala"
@val fileOps = read! cwd/'ops/'src/'main/'scala/'ammonite/'ops/"FileOps.scala"
@val found = (
  ".*/\\*\\*(\n\\s*\\*.*)+\n.*?extends.*?Op[^{]*".r
    .findAllIn(fileOps)
    .mkString("\n")
    .lines
    .map(" "+_)
    .mkString("\n")
)
@a(
  href:="https://github.com/lihaoyi/ammonite",
  position.absolute,
  top:=0,right:=0,border:=0,
  img(
    src:="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67",
    alt:="Fork me on GitHub"
  )
)

@sect("Ammonite", "A Modernized Scala REPL")

  @p
    Ammonite is a cleanroom re-implementation of the Scala REPL from first principles. It is much more featureful than the default REPL and comes with a lot of @sect.ref("Features", "ergonomic improvements") and @sect.ref("Configuration", "configurability") that may be familiar to people coming from IDEs or other REPLs such as @a("IPython", href:="ipython.org") or @a("Zsh", href:="http://www.zsh.org/"). It can be combined with @sect.ref{Ammonite-Ops} to replace Bash as your systems shell, but also can be used alone as a @sect.ref("Features", "superior") version of the default Scala REPL, or as a @sect.ref("Debugging", "debugging tool").

  @p
    One way to get started with Ammonite is to download the standalone executable:

  @hl.sh
    $ curl -L -o amm http://git.io/vGksC; chmod +x amm; ./amm


  @hl.scala
    Loading Ammonite Repl...
    @@ List(Seq(Seq("mgg", "mgg", "lols"), Seq("mgg", "mgg")), Seq(Seq("ggx", "ggx"),Seq("ggx", "ggx", "wtfx")))
    res1: List[Seq[Seq[String]]] = List(
      List(List("mgg", "mgg", "lols"), List("mgg", "mgg")),
      List(List("ggx", "ggx"), List("ggx", "ggx", "wtfx"))
    )

    @@ load.ivy("com.lihaoyi" %% "scalatags" % "0.4.5") // load a library

    @@ import scalatags.Text.all._
    import scalatags.Text.all._

    @@ a("omg", href:="www.google.com").render
    res3: String = """
    <a href="www.google.com">omg</a>
    """

  @p
    If you want some initialization code available to the REPL, you can add it to your @code{~/.ammonite/predef.scala}.

  @p
    You can also try out Ammonite in an existing SBT project, add the following to your @code{build.sbt}

  @hl.scala
    libraryDependencies += "com.lihaoyi" % "ammonite-repl" % "@ammonite.Constants.version" % "test" cross CrossVersion.full

    initialCommands in (Test, console) := """ammonite.repl.Repl.run("")"""

  @p
    After that, simple hit
  @code
    sbt projectName/test:console
  @p
    To activate the Ammonite REPL

  @p
    You can also pass a string to the @code{run} call containing any commands or imports you want executed at the start of every run. If you want Ammonite to be available in all projects, simply add the above snippet to a new file @code{~/.sbt/0.13/global.sbt}.

  @p
    If you have any questions, come hang out on the @sect.ref("Community", "mailing list or gitter channel") and get help!

  @sect{Features}
    @p
      Ammonite-REPL supports many more features than the default REPL, including:

    @sect{Artifact Loading}

      @hl.ref(ammoniteTests/"ProjectTests.scala", Seq("standalone", "@"), "\"\"\"")

      @p
        Ammonite allows you to load artifacts directly from maven central by copy & pasting their SBT ivy-coordinate-snippet. In addition, you can also load in jars as @hl.scala{java.io.File}s to be included in the session or simple @hl.scala{String}s to be executed using the @hl.scala{load} command.

      @p
        This makes Ammonite ideal for trying out new libraries or tools. You can pull down projects like @a("Scalaz", href:="https://github.com/scalaz/scalaz") or @a("Shapeless", href:="https://github.com/milessabin/shapeless") and immediately start working with them in the REPL:

      @hl.ref(ammoniteTests/"ProjectTests.scala", Seq("scalaz", "@"), "\"\"\"")

      @hl.ref(ammoniteTests/"ProjectTests.scala", Seq("shapeless", "@"), "\"\"\"")

      @p
        Even non-trivial web frameworks like Finagle or Akka-HTTP can be simply pulled down and run in the REPL!

      @hl.ref(ammoniteTests/"ProjectTests.scala", Seq("finagle", "@"), "\"\"\"")

      @hl.ref(ammoniteTests/"ProjectTests.scala", Seq("akkahttp", "@"), "\"\"\"")

    @sect{Pretty-printed output}

      @hl.ref(advancedTests, Seq("'pprint", "@"), "\"\"\"")

      @p
        Ammonite-REPL uses @sect.ref{PPrint} to display its output by default. That means that everything is nicely formatted to fit within the width of the terminal, and is copy-paste-able!

      @p
        By default, Ammonite @sect.ref("Configurable Truncation", "truncates") the pretty-printed output to avoid flooding your terminal. If you want to disable truncation, call @hl.scala{show(...)} on your expression to pretty-print it's full output. You can also pass in an optional @hl.scala{height = ...} parameter to control how much you want to show before truncation.
    @sect{Configurable Truncation}
      @hl.ref(advancedTests, Seq("'truncation", "@"), "\"\"\"")

      @p
        Ammonite-REPL intelligently truncates your output when it's beyond a certain size. You can request for the full output to be printed on-demand, print a certain number of lines, or even change the implicit @code{pprintConfig} so subsequent lines all use your new configuration.

    @sect{Syntax Highlighting}
      @img(src:="Highlighting.png", width:="100%")
      @p
        Ammonite syntax highlights both the code you're entering as well as any output being echoed in response. This should make it much easier to work with larger snippets of input.
      @p
        All colors are configurable, and you can easily turn off colors entirely via the @sect.ref{Configuration}.
      @p
        Stack traces are similarly highlighted, for easier reading:

      @img(src:="ColoredTraces.png", width:="100%")

    @sect{Improved Editing}
      @p
        Ammonite by default ships with a custom implementation of readline, which provides...

     @ul
       @li
         Multi-line editing! You can use the @b{Up} and @b{Down} arrows to navigate between lines within your snippet. This makes dealing with larger snippets of code much easier.
       @li
         Desktop key-bindings! You can use @b{Alt-Left}/@b{Right} to move forward/backwards by one word at a time or hold down @b{Shift} to select text to delete. These compose as you'd be used to: e.g. @b{Shift-Up} selects all the text between your current cursor and the same column one row up.
       @li
         Console key-bindings! All the readline-style navigation hotkeys like @b{Ctrl-W} to delete a word or @b{Esc-Left}/@b{Right} to navigate one word left/right still work.



    @sect{Superior Autocomplete}
      @p
        The original Scala REPL provides no autocomplete except for the most basic scenarios of @hl.scala{value.<complete>}. In the Ammonite-REPL, you get the same autocomplete-anywhere support that you get in a modern IDE.

      @hl.scala("""
        @ Seq(1, 2, 3).map(x => x.)
        getClass            ##                  asInstanceOf        isInstanceOf
        toString            hashCode            equals              !=
        ==                  %                   /                   *
        -                   +                   ^                   &
        |                   >=                  >                   <=
        <                   >>                  >>>                 <<
        unary_-             unary_+             unary_~             toDouble
        toFloat             toLong              toInt               toChar
        toShort             toByte              compareTo           doubleValue
        ...

        @ Futu
        scala.collection.parallel.FutureThreadPoolTasks
        scala.collection.parallel.FutureTasks
        scala.concurrent.impl.Future$PromiseCompletingRunnable
        scala.concurrent.impl.Future
        scala.concurrent.Future
        scala.concurrent.FutureTaskRunner
        scala.concurrent.Future$InternalCallbackExecutor
        scala.concurrent.Future$class
        java.util.concurrent.Future
        java.util.concurrent.FutureTask$WaitNode
        java.util.concurrent.FutureTask
        com.sun.corba.se.impl.orbutil.closure.Future
      """)

      @p
        Neither of these examples work in the standard Scala REPL.

    @sect{Interrupting run-away execution with Ctrl-C}
      @hl.scala("""
        @ while(true) ()
        ... hangs ...
        ^Ctrl-C
        Interrupted!

        @
      """)
      @p
        The traditional Scala REPL doesn't handle runaway code, and gives you no option but to kill the process, losing all your work. Ammonite-REPL lets you interrupt the thread, stop the runaway-command and keep going.

    @sect{Compiler-crash Robustness}
      @hl.ref(ammoniteTests/"FailureTests.scala", Seq("compilerCrash", "@"), "\"\"\"")

      @p
        The default Scala REPL throws away all your work if the compiler crashes. This doesn't make any sense, because all the compiler is is a dumb @hl.scala{String => Array[Byte]} pipe. In the Ammonite, we simply swap out the broken compiler for a new one and let you continue your work.
    @sect{Other Fixes}
      @p
        Apart from the above features, the Ammonite REPL fixes a large number of bugs in the default Scala REPL, including but not limited to:
      @ul
        @val bugs = Seq("6302", "8971", "9249", "4438", "8603", "6660", "7953", "6659", "8456", "1067", "8307", "9335")
        @for(bug <- bugs){
          @li(a("SI-"+bug, href:="https://issues.scala-lang.org/browse/SI-"+bug))
        }
  @sect{Builtins}
    @p
      Ammonite contains a range of useful built-ins implemented as normal functions. Everything inside the @hl.scala{ReplAPI} trait is imported by default and can be accessed directly by default to control the console.

    @hl.ref(replSource/'frontend/"ReplAPI.scala", "trait ReplAPI", "// End of ReplAPI")

  @sect{Multiline Input}
    @p
      To enter multiline input into the Ammonite-REPL, simply wrap the multiple lines in curly braces @hl.scala("{ ... }"), and Ammonite will wait until you close it before evaluating the contents:

    @hl.ref(advancedTests, Seq("'unwrapping", "@"))

    @p
      As you can see, the contents of the @hl.scala("{ ... }") block are unwrapped and evaluated as top-level statements. You can use this to e.g. declare mutually recursive functions or classes & companion-objects without being forced to squeeze everything onto a single line.

    @p
      If you don't want this un-wrapping behavior, simply add another set of curlies and the block will be evaluated as a normal block, to a single expression:

    @hl.ref(advancedTests, Seq("'forceWrapping", "@"))

  @sect{Script Files}
    @p
      Ammonite defines a format that allows you to load external scripts into the REPL; this can be used to save common functionality so it can be used at a later date. In the simplest case, a script file is simply a sequence of Scala statements, e.g.

    @hl.scala
      // print banner
      println("Welcome to the XYZ custom REPL!!")

      // common imports
      import sys.process._
      import collection.mutable

      // common initialization code
      ...

    @p
      By default, everything in a script is compiled and executed as a single block. That means that if you want to perform classpath-modifying operations, such as @hl.scala{load.jar} or @hl.scala{load.ivy}, its results will not be available within the same script if you want to use methods, values or packages defined in the loaded code. To make this work, break the script up into multiple compilation units with an @@ sign, e.g.

    @hl.scala
      // print banner
      println("Welcome to the XYZ custom REPL!!")

      load.ivy("org.scalaz" %% "scalaz-core" % "7.1.1")

      @@

      // common imports
      import scalaz._
      import Scalaz._

      // common initialization code
      ...
    @p
      Ammonite provides two ways to load scripts, @hl.scala{load.exec} and @hl.scala{load.module}.

    @p
      With @hl.scala{load.exec} the script is executed like it was pasted in the REPL. Exec scripts can access all values previously defined in the REPL, and all side-effects are guaranteed to be applied. This is useful for one-off sets of commands.
    @p
      With @hl.scala{load.module}, the script is loaded like a Scala module. That means it can't access values previously defined in the REPL, but it is guaranteed to only execute once even if loaded many times by different scripts. If you want to execute the script code multiple times, put it in a function and call it after you load the script.

     @p
       Any scripts you load can themselves load scripts. You can also run scripts using the Ammonite executable from an external shell (e.g. bash):

    @hl.scala
      bash$ ./amm path/to/script.scala

    @p
      All types, values and imports defined in scripts are available to commands entered in REPL after loading the script.

  @sect{Configuration}
    @p
      Ammonite is configured via Scala code, that can live in the @code{~/.ammonite/predef.scala} file, passed in through SBT's @hl.scala{initialCommands}, or passed to the command-line executable as @code{--predef='...'}.

    @p
      Anything that you put in @code{predef.scala} will be executed when you load the Ammonite REPL. This is a handy place to put common imports, setup code, or even call @hl.scala{load.ivy} to @sect.ref("Artifact Loading", "load third-party jars"). The compilation of the predef is cached, so after the first run it should not noticeably slow down the initialization of your REPL.

    @p
      Some examples of things you can configure:

    @hl.ref(ammoniteTests/"BuiltinTests.scala", Seq("basicConfig", "@"))

    @sect{Refs}
      @p
        By default, all the values you're seeing here with the @code{()} after them are @hl.scala{Ref}s, defined as

      @hl.ref(replSource/"Util.scala", "trait StableRef", "object Ref")

      @p
        As you can see from the signature, you can basically interact with the @hl.scala{Ref}s in two ways: either getting or setting their values as values, or binding their values to expressions that will be evaluated every time the @hl.scala{Ref}'s value is needed.

      @p
        As an example of the latter, you can use @hl.scala{bind} to set your @hl.scala{prompt} to always include your current working directory

      @hl.scala
        repl.prompt.bind(wd.toString + "@@ ")

      @p
        As is common practice in other shells. Further modifications to make it include e.g. your current branch in Git (which you can call through Ammonite's @sect.ref("Spawning Subprocess", "subprocess API") or the current timestamp/user are similarly possible.

    @sect{Compiler Flags}
      @p
        Apart from configuration of the rest of the shell through @sect.ref{Refs}, configuration of the Scala compiler takes place separately through the compiler's own configuration mechanism. You have access to the compiler as @code{compiler}, and can modify its settings as you see fit. Here's an example of this in action:

      @hl.ref(ammoniteTests/"BuiltinTests.scala", Seq("settings", "@"))

      @p
        If you want these changes to always be present, place them in your @code{~/.ammonite/predef.scala}.
  @sect{Filesystem Operations}
    @p
      Ammonite uses @sect.ref{Ammonite-Ops} to provide a nice API to use filesystem operations. To access it, simply call
    @hl.scala
      import ammonite.ops._
    @p
      Or add it to your @hl.scala{~/.ammonite/predef.scala} if you want it available all the time in your REPL. The Ammonite REPL also provides some additional command-line-friendly functionality on top of the default Ammonite-Ops commands:
    @hl.ref(replSource/'frontend/"ReplAPI.scala", "trait OpsAPI", "// End of OpsAPI")
    @p
      These are imported by default into every repl session, and basically let you treat the Ammonite-REPL much more like a Bash shell. You can `hl.scala{cd!} in and out of directories, and treat relative paths as shorthand for absolute paths when working in the shell. This means you can enter commands like
    @hl.scala
      @@ cd! up

      @@ cd! 'foldername

      @@ ls! 

      @@ ls! 'foldername

      @@ stat! "folder-name-with-dashes"/"file.txt'

    @p
      Without having to repeatedly qualify theses relative paths with your current working directory. You can use Ammonite-Ops' support for @sect.ref{Spawning Subprocesses} to call external programs, even interactive ones like Python or SBT!

    @hl.scala
      @@ %python
      Python 2.7.6 (default, Sep  9 2014, 15:04:36)
      [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.39)] on darwin
      Type "help", "copyright", "credits" or "license" for more information.
      >>> print "Hello %s%s" % ("World", "!"*3)
      Hello World!!!
      >>> ^D
      res3: Int = 0

      @@ %sbt
      [info] Loading global plugins from /Users/haoyi/.sbt/0.13/plugins
      [info] Updating {file:/Users/haoyi/.sbt/0.13/plugins/}global-plugins...
      [info] Resolving org.fusesource.jansi#jansi;1.4 ...
      [info] Done updating.
      [info] Set current project to haoyi (in build file:/Users/haoyi/)
      >
  @sect{Debugging}
    @p
      Ammonite can be used as a tool to debug any other Scala program, by conveniently opening a REPL at any point within your program with which you can interact with live program data, similar to pdb/ipdb in Python. To do so, first add Ammonite to your classpath, e.g. through this SBT snippet:
    @hl.scala
      libraryDependencies += "com.lihaoyi" % "ammonite-repl" % "@ammonite.Constants.version" cross CrossVersion.full

    @p
      Note that unlike the snippet given @sect.ref("Ammonite", "above"), we leave out the @hl.scala{% "test"} because we may want ammonite to be available within the "main" project, and not just in the unit tests. Then, anywhere within your program, you can place a breakpoint via:

    @hl.scala
      import ammonite.repl.Repl._
      debug("name1" -> value1, "name2" -> value2, ...)

    @p
      And when your program reaches that point, it will pause and open up an Ammonite REPL with the values you provided it bound to the names you gave it. From there, you can interact with those values as normal Scala values within the REPL. Use @code{Ctrl-D} or @hl.scala{exit} to exit the REPL and continue normal program execution.
    @p
      Here's an example of it being used to debug changes to the @a("WootJS webserver", href:="https://github.com/d6y/wootjs"):

    @img(src:="Debugging.png", width:="100%")
    @p
      In this case, we added the @hl.scala{debug} statement within the websocket frame handler, so we can inspect the values that are taking part in the client-server data exchange. You can also put the @hl.scala{debug} statement inside a conditional, to make it break only when certain interesting situations (e.g. bugs) occur.

    @p
      As you can see, you can bind the values you're interested in to names inside the debug REPL, and once in the REPL are free to explore them interactively.
    @p
      The @hl.scala{debug()} call returns @hl.scala{: Any}; by default, this is @hl.scala{(): Unit}, but you can also return custom values by passing in an argument to @hl.scala{exit(...)} when you exit the REPL. This value will then be returned from @hl.scala{debug()}, and can be used in the rest of your Scala application.

@sect("Ammonite-Ops", "Rock-solid Filesystem Operations")
  @p
    Ammonite-Ops is a library to make common filesystem operations in Scala as concise and easy-to-use as from the Bash shell, while being robust enough to use in large applications without getting messy. It lives in the same repo as the Ammonite REPL, but can easily be used stand-alone in a normal SBT/maven project.

  @p
    To get started with Ammonite-Ops, add this to your @code{build.sbt}:

  @hl.scala{libraryDependencies += "com.lihaoyi" %% "ammonite-ops" % "@ammonite.Constants.version"}

  @p
    And you're all set! Here's an example of some common operations you can do with Ammonite-Ops

  @val opsTests = 'ops/'src/'test/'scala/'test/'ammonite/'ops
  @val opsExamples = opsTests/"ExampleTests.scala"
  @val pathsScala = 'ops/'src/'main/'scala/'ammonite/'ops/"Path.scala"
  @hl.ref(opsExamples, Seq("longExample", "import"), "assert(")

  @p
    These examples make heavy use of Ammonite-Ops' @sect.ref{Paths}, @sect.ref{Operations} and @sect.ref{Extensions} to achieve their minimal, concise syntax
  @p
    As you can see, Ammonite-Ops replaces the common mess of boilerplate:

  @hl.ref('ops/'src/'test/'scala/'test/'ammonite/'ops/"ExampleTests.scala", Seq("comparison", "def removeAll"), "assert(")

  @p
    With a single, sleek expression:

  @hl.ref(opsExamples, Seq("comparison", "assert", "rm!"), "assert(")

  @p
    That handles the common case for you: recursively deleting folders, not-failing if the file doesn't exist, etc.

  @sect{Paths}
    @p
      Ammonite uses strongly-typed data-structures to represent filesystem paths. The two basic versions are:

    @ul
      @li
        @code{Path}: an absolute path, starting from the root

      @li
        @code{RelPath}: a relative path, not rooted anywhere

    @p
      Generally, almost all commands take absolute @code{Path}s. These are basically defined as:

    @hl.ref(pathsScala, "class Path", "")

    @p
      With a number of useful operations that can be performed on them. Absolute paths can be created in a few ways:

    @hl.ref(opsExamples, Seq("constructingPaths", "//"), "}")

    @p
      Note that there are no in-built operations to change the `cwd`. In general you should not need to: simply defining a new path, e.g.

    @hl.ref(opsExamples, Seq("newPath", "val"), "}")

    @p
      Should be sufficient for most needs.

    @p
      Above, we made use of the @hl.scala{cwd} built-in path. There are a number of @hl.scala{Path}s built into Ammonite:

    @ul
      @li
        @hl.scala{cwd}: The current working directory of the process. This can't be changed in Java, so if you need another path to work with the convention is to define a @hl.scala{wd} variable.
      @li
        @hl.scala{root}: The root of the filesystem.
      @li
        @hl.scala{home}: The home directory of the current user.
      @li
        @hl.scala{makeTmp}: Creates a temporary folder and returns the path.

  @sect{RelPaths}
    @p
      @hl.scala{RelPath}s represent relative paths. These are basically defined as:

    @hl.ref(pathsScala, "class RelPath", "")

    @p
      The same data structure as @hl.scala{Path}s, except that they can represent a number of @hl.scala{up}s before the relative path is applied. They can be created in the following ways:

    @hl.ref(opsExamples, Seq("relPaths", "//"), ":")

    @p
      In general, very few APIs take relative paths. Their main purpose is to be combined with absolute paths in order to create new absolute paths. e.g.

    @hl.ref(opsExamples, Seq("relPathCombine", "val"), "}")

    @p
      @hl.scala{up} is a relative path that comes in-built:

    @hl.ref(opsExamples, Seq("relPathUp", "val"), "}")

    @p
      Note that all paths, both relative and absolute, are always expressed in a canonical manner:

    @hl.ref(opsExamples, Seq("canonical", "assert"), "}")

    @p
      So you don't need to worry about canonicalizing your paths before comparing them for equality or otherwise manipulating them.

  @sect{Path Operations}

    @p
      Ammonite's paths are transparent data-structures, and you can always access the @hl.scala{segments} and @hl.scala{ups} directly. Nevertheless, Ammonite defines a number of useful operations that handle the common cases of dealing with these paths:

    @hl.ref(pathsScala, "trait BasePath", "trait")

    @p
      In this definition, @hl.scala{ThisType} represents the same type as the current path; e.g. a @hl.scala{Path}'s @hl.scala{/} returns a @hl.scala{Path} while a @hl.scala{RelPath}'s @hl.scala{/} returns a @hl.scala{RelPath}. Similarly, you can only compare or subtract paths of the same type.

    @p
      Apart from @hl.scala{RelPath}s themselves, a number of other data structures are convertible into @hl.scala{RelPath}s when spliced into a path using @hl.scala{/}:

    @ul
      @li
        @hl.scala{String}s
      @li
        @hl.scala{Symbols}s
      @li
        @hl.scala{Array[T]}s where @hl.scala{T} is convertible into a @hl.scala{RelPath}
      @li
        @hl.scala{Seq[T]}s where @hl.scala{T} is convertible into a @hl.scala{RelPath}

  @sect{Operations}
    @p
      @sect.ref{Paths} not aren't interesting on their own, but serve as a base to use to perform filesystem operations in a concise and easy to use way. Here is a quick tour of the core capabilities that Ammonite-Ops provides:

    @hl.ref(opsExamples, Seq("'reference", "import"))

    @p
      Here is the definition for these operations:

    @hl.scala(found)

    @p
      In these definitions, @hl.scala{Op1} and @hl.scala{Op2} are isomorphic to @hl.scala{Function1} and @hl.scala{Function2}. The main difference is that ops can be called in two ways:

    @hl.scala
      rm(filepath)
      rm! filepath

    @p
      The latter syntax allows you to use it more easily from the command line, where remembering to close all your parenthesis is a hassle. Indentation signifies nesting, e.g. in addition to @hl.scala{write!} you also have @hl.scala{write.append!} and @hl.scala{write.over!}

    @p
      All of these operations are pre-defined and strongly typed, so feel free to jump to their implementation to look at what they do or what else is available.

    @p
      In general, each operator has sensible/safe defaults:

    @ul
      @li
        @hl.scala{rm} and @hl.scala{cp} are recursive
      @li
        @hl.scala{rm} ignores the file if it doesn't exist
      @li
        all operations that create a file or folder (@hl.scala{mkdir}, @hl.scala{write}, @hl.scala{mv}) automatically create any necessary parent directories
      @li
        @hl.scala{write} also does @i{not} stomp over existing files by default. You need to use @hl.scala{write.over}
    @p
      In general, this should make these operations much easier to use; the defaults should cover the 99% use case without needing any special flags or fiddling.

  @sect{Extensions}
    @p
      Ammonite-Ops contains a set of extension methods on common types, which serve no purpose other than to make things more concise. These turn Scala from a "relatively-concise" language into one as tight as Bash scripts, while still maintaining the high level of type-safety and maintainability that comes with Scala code.

    @sect{Traversable}
      @p
        These extensions apply to any @hl.scala{Traversable}: @hl.scala{Seq}s, @hl.scala{List}s, @hl.scala{Array}s, and others.
      @ul
        @li
          @hl.scala{things | f} is an alias for @hl.scala{things map f}
        @li
          @hl.scala{things || f} is an alias for @hl.scala{things flatMap f}
        @li
          @hl.scala{things |? f} is an alias for @hl.scala{things filter f}
        @li
          @hl.scala{things |& f} is an alias for @hl.scala{things reduce f}
        @li
          @hl.scala{things |! f} is an alias for @hl.scala{things foreach f}
      @p
        These should behave exactly the same as their implementations; their sole purpose is to make things more concise at the command-line.

    @sect{Pipeable}
      @ul
        @li
          @hl.scala{thing |> f} is an alias for @hl.scala{f(thing)}

      @p
        This lets you flip around the function and argument, and fits nicely into the Ammonite's @hl.scala{|} pipelines.

    @sect{Callable}
      @ul
        @li
          @hl.scala{f! thing} is an alias for @hl.scala{f(thing)}

      @p
        This is another syntax-saving extension, that makes it easy to call functions without having to constantly be opening and closing brackets. It does nothing else.

  @sect{Chaining}
    @p
      The real value of Ammonite is the fact that you can pipe things together as easily as you could in Bash. No longer do you need to write reams of boilerplate. to accomplish simple tasks. Some of these chains are listed at the top of this readme, here are a few more fun examples:

    @hl.ref(opsExamples, Seq("longExample", "// Chains", "// Move all files"), "assert(")

    @p
      As you can see, you can often compose elaborate operations entirely naturally using the available pipes, without needing to remember any special flags or techniques.

    @p
      Here's another example:

    @hl.ref(opsExamples, Seq("noLongLines", ""))

  @sect{Spawning Subprocesses}
    @p
      Ammonite-Ops provides easy syntax for anyone who wants to spawn sub-processes, e.g. commands like @code{ls} or @code{git commit -am "wip"}. This is provided through the @hl.scala{%} and @hl.scala{%%} operators, which are used as follows:

    @hl.scala
      @@ import ammonite.ops._
      @@ import ammonite.ops.ImplicitWd._
      @@ %ls
      build.sbt	log		ops		readme		repl		terminal
      echo		modules		project		readme.md	target		tools
      res2: Int = 0
      @@ %%ls
      res3: CommandResult =
      build.sbt
      echo
      log
      modules
      ops
      project
      readme
      readme.md
      repl
      target
      terminal
      ...

    @p
      In short, @hl.scala{%} lets you run a command as you would in bash, and dumps the output to standard-out in a similar way, returning the return-code. This lets you run @code{git} commands, edit files via @code{vim}, open @code{ssh} sessions or even start @code{SBT} or @code{Python} shells right from your Scala REPL!
    @p
      @hl.scala{%%} on the other hand is intended for programmatic usage: rather than printing to stdout, it returns a @hl.scala{CommandResult}, which is simply a @hl.scala{Stream[String]} of the lines from the subprocess. @hl.scala{%%} throws an exception if the return-code is non-zero. The returned @hl.scala{Stream[String]} can then be used however you like.
    @p
      You can also use backticks to execute commands which aren't valid Scala identifiers, e.g.

    @hl.scala
      @@ %`ssh-add`
      Enter passphrase for /Users/haoyi/.ssh/id_rsa:

    @p
      Lastly, you can also pass arguments into these subprocess calls, as Strings or Symbols:
    @hl.scala
      @@ %git 'branch
        gh-pages
        history
      * master
        speedip
      res4: Int = 0

      @@ %%git 'branch
      res5: CommandResult =
        gh-pages
        history
      * master
        speedip

      @@ %%git('checkout, "master")
      Already on 'master'
      res6: CommandResult =
      M	readme/Index.scalatex
      Your branch is up-to-date with 'origin/master'.

      @@ %git("checkout", 'master)
      M	readme/Index.scalatex
      Already on 'master'
      Your branch is up-to-date with 'origin/master'.
      res8: Int = 0
    @p
      Ammonite-Ops currently does not provide many convenient ways of piping together multiple processes, but support may come in future if someone finds it useful enough to implement.

    @p
      @hl.scala{%} calls subprocesses in a way that is compatible with a normal terminal. That means you can easily call things like @hl.scala{%vim} to open a text editor, @hl.scala{%python} to open up a Python terminal, or @hl.scala{%sbt} to open up the SBT prompt!
    @hl.scala
      @@ %python
      Python 2.7.6 (default, Sep  9 2014, 15:04:36)
      [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.39)] on darwin
      Type "help", "copyright", "credits" or "license" for more information.
      >>> print "Hello %s%s" % ("World", "!"*3)
      Hello World!!!
      >>> ^D
      res3: Int = 0

      @@ %sbt
      [info] Loading global plugins from /Users/haoyi/.sbt/0.13/plugins
      [info] Updating {file:/Users/haoyi/.sbt/0.13/plugins/}global-plugins...
      [info] Resolving org.fusesource.jansi#jansi;1.4 ...
      [info] Done updating.
      [info] Set current project to haoyi (in build file:/Users/haoyi/)
      >

    @p
      @hl.scala{%%} does not do this.
    @sect{Environment Variables}
      @p
        Ammonite lets you pass in environment variables to subprocess calls; just pass them in as named arguments when you invoke the subprocess ia @code{%} or @code{%%}:

      @hl.ref(opsTests/"ShelloutTests.scala", Seq("'envArgs", "val"))

    @sect{Invoking Files}
      @p
        You can invoke files on disk using @code{%} and @code{%%} the same way you can invoke shell commands:

      @hl.ref(opsTests/"ShelloutTests.scala", Seq("'filebased", "val"))
@sect{Community}
  @ul
    @li
      @a("Mailing List", href:="https://groups.google.com/forum/#!forum/ammonite-scala")
    @li
      @a("Gitter Channel", href:="https://gitter.im/lihaoyi/Ammonite")

@sect{Changelog}
  @sect{0.4.7}
    @ul
      @li
        Fix execution of files via symbols in the current working directory.
  @sect{0.4.6}
    @ul
      @li
        Provide a way of @sect.ref{Invoking Files} and passing @sect.ref{Environment Variables}
      @li
        Documented existing approach for setting @sect.ref{Compiler Flags}
      @li
        Fixed a bug in the readline re-implementation causing barely-full lines in the terminal to mess up cursor positioning and line re-drawing
      @li
        Remove @code{cache1234567890abcdef1234567890abcdef} objects from the autocomplete list, because they're not helpful
      @li
        Trim all the useless members of @hl.scala{Any} from the default import lists.
      @li
        Fix a file-handle-leak for most usages of @code{read.lines} and @code{ls}/@code{ls.rec}
      @li
        Fix bugs @a("#186", href:="https://github.com/lihaoyi/Ammonite/issues/186"), @a("#152", href:="https://github.com/lihaoyi/Ammonite/issues/152"), @a("#149", href:="https://github.com/lihaoyi/Ammonite/issues/149"), @a("#180", href:="https://github.com/lihaoyi/Ammonite/issues/180")
  @sect{0.4.5}
    @ul
      @li
        Fix for running Ammonite using OpenJDK, thanks to @a("Johannes Rudolph", href:="https://github.com/jrudolph")
      @li
        Support for HOME and END keys, thanks to @a("Johannes Rudolph", href:="https://github.com/jrudolph")
      @li
        Fix for incorrect syntax highlighting (@a("#159", href:="https://github.com/lihaoyi/Ammonite/issues/159"))
      @li
        Support for loading compiler plugins, thanks to @a("Alexandre Archambault", href:="https://github.com/alexarchambault")
      @li
        You can now use Ammonite as a @sect.ref{Debugging} tool like Python's pdb, placing an interactive breakpoint anywhere within a normal Scala application

  @sect{0.4.4}
    @ul
      @li
        @a("Lots", href:="https://github.com/lihaoyi/Ammonite/pull/153") @a("and", href:="https://github.com/lihaoyi/Ammonite/pull/158") @a("lots", href:="https://github.com/lihaoyi/Ammonite/pull/157") of terminal improvements, courtesy of @a("Erik Osheim", href:="https://github.com/non")
      @li
        Only the last @hl.scala("@")-delimited block in a script loaded via @hl.scala{load.module} gets its names dumped into the REPL's environment now, letting you create some semblance of hygiene, thanks to @a("Laszlo Mero", href:="https://github.com/laci37")
  @sect{0.4.3}
    @ul
      @li
        Remove embarassing debug println left behind in autocomplete code
      @li
        Fix @code{pathSeparator} so Ammonite-REPL is at least basically-runnable on windows, although buggy
      @li
        Update to more robust version of pprint to fix @a("#140", href := "https://github.com/lihaoyi/Ammonite/issues/140")
  @sect{0.4.2}
    @ul
      @li
        Fix @a("#139: Can't fix typos?", href := "https://github.com/lihaoyi/Ammonite/issues/139")
      @li
        Fix bad wrapping of long lines in ammonite-repl
  @sect{0.4.1}
    @ul
      @li
        Fix crasher running the REPL on new machines
  @sect{0.4.0}
    @ul
      @li
        Re-added support for 2.10.x, minus features that don't work in it (e.g. scope-aware type-printing)
      @li
        Added a @sect.ref("Ammonite", "standalone distributable") that comes bundled with Scala 2.10.4 or 2.11.7, letting you quickly load and experiment with libraries without SBT
      @li
        User input now has @sect.ref{Syntax Highlighting} by default!
      @li
        Exception stack traces are now @sect.ref("Syntax Highlighting", "highlighted") as well, to make them easier to read
      @li
        @sect.ref("Pretty-printed output", "Pretty-printing") has been extracted into a separate project, and aside from that is greatly improved. Many more common cases (e.g. sealed trait hierarchies) are now pretty-printed rather than falling back to @code{toString}
      @li
        Exposed the @sect.ref("Configurable Truncation", "show") function by default, letting you pretty-print any value with custom configuration (wrapping-width, truncation-height, colors, ...)
      @li
        Fixed cases where PPrint/TPrint was causing compilation errors
      @li
        Persistent data is now stored in a @code{~/.ammonite} folder. This includes @code{~/.ammonite/history}, @code{~/.ammonite/predef.scala}, and various cache, thanks to @a("Laszlo Mero", href:="https://github.com/laci37")
      @li
        You can now define a @code{~/.ammonite/predef.scala} @sect.ref("Configuration") file which will be executed the first thing when the Ammonite REPL is loaded. This is useful for common imports, @hl.scala{load.ivy}ing libraries, or other configuration for your REPL
      @li
        Added the ability to load arbitrary @sect.ref{Script Files} via @hl.scala{load.exec} and @hl.scala{load.module}, thanks to @a("Laszlo Mero", href:="https://github.com/laci37")
      @li
        @sect.ref{Configuration} that was previously passed into the @hl.scala{REPL}s constructor is now done in-REPL,
      @li
        @sect.ref("Improved Editing", "Multi-line editing and other features") via a custom terminal interface that should behave just like readline, but with added conveniences.
      @li
        Removed the ability to reload classes; using @hl.scala{load.ivy} no longer causes all existing values to be lazily recomputed.
      @li
        Added the @sect.ref("Filesystem Operations", "cd! and wd") built-ins to make working with filesystem operations via @sect.ref{Ammonite-Ops} more pleasant
      @li
        Evaluated values of type @hl.scala{Unit} are no longer echo-ed to the user
      @li
        Performance improvements to the startup time of the REPL, with @a("more to come", href:="https://github.com/lihaoyi/Ammonite/issues/135")
      @li
        Third-party library resolution via @hl.scala{load.ivy} is now cached after the first call, letting you e.g. load libraries in your @code{~/.ammonite/predef.scala} without waiting for the slow ivy-resolution every startup
      @li
        Standardized the use of @sect.ref{Refs} for configuration, including the ability to bind them "live" to the value of an expression.
      @li
        Allows you to trivially @sect.ref("Spawning Subprocesses", "spawn subprocesses"), letting you run @code{git} commands, edit files via @code{vim}, open @code{ssh} sessions or even start @code{SBT} or @code{Python} shells right from your Scala REPL
  @sect{0.3.2}
    @ul
      @li
        Fix pretty-printing of higher-kinded types.
      @li
        Drop support for 2.10.x; ammonite is 2.11.x-only now

  @sect{0.3.1}
    @ul
      @li
        Many of the collection @hl.scala{PPrint}s are much lazier and will avoid stringifying the whole collection if its going to get truncated anyway.
      @li
        Types now get printed semi-qualified (depending on what's in scope), with simple highlighting.
      @li
        You can define custom @hl.scala{TPrint[T]}s to provide custom printing for any type.
      @li
        Operator-named two-param generic types are now printed infix by default.

  @sect{0.3.0}
    @ul
      @li
        allow @hl.scala{predef} parameter to be passed into @hl.scala{Repl.run()} call, letting you configure initialization commands or imports
      @li
        Compilation errors in expressions no longer show synthetic code in the message
      @li
        Ivy module loading now lets you configure verbosity level
      @li
        Defining macros in the REPL and using them in subsequent lines now works
      @li
        Output lines are now truncated past a certain length, which is configurable, thanks to @a("Laszlo Mero", href:="https://github.com/laci37")

  @sect{0.2.9}
    @ul
      @li
        Lots of improvements to @code{Ctrl-C} and @code{Ctrl-D} handling, to make it behave more like other REPLs

  @sect{0.2.8}
    @ul
      @li
        Fix #47: PPrint derivation fails with nested case class
      @li
        Fix #14: Exception when trying to use Ammonite REPL #15 by cross building against Scala 2.10.{3,4,5} and 2.11.{3,4,5,6}
      @li
        Autocomplete results are sorted alphabetically (Fixed #42)
      @li
        Fix #39: nothing echoed on multiple import
      @li
        Importing things from Java packages now works properly
